# üìò Apuntes: Criteria API y QueryDSL en Spring Boot

---

## üìë √çndice

- [üìò Apuntes: Criteria API y QueryDSL en Spring Boot](#-apuntes-criteria-api-y-querydsl-en-spring-boot)
  - [üìë √çndice](#-√≠ndice)
  - [1. Introducci√≥n](#1-introducci√≥n)
  - [2. Criteria API](#2-criteria-api)
    - [Ventajas y desventajas](#ventajas-y-desventajas)
    - [Ejemplos b√°sicos](#ejemplos-b√°sicos)
  - [3. QueryDSL](#3-querydsl)
    - [¬øQu√© es QueryDSL?](#qu√©-es-querydsl)
    - [Dependencias en Spring Boot](#dependencias-en-spring-boot)
    - [Generaci√≥n de Q-classes](#generaci√≥n-de-q-classes)
    - [Ejemplos b√°sicos (QueryDSL)](#ejemplos-b√°sicos-querydsl)
    - [Comparativa con Criteria API](#comparativa-con-criteria-api)
  - [4. Buenas pr√°cticas](#4-buenas-pr√°cticas)
- [üìò Integraci√≥n de QueryDSL con JpaRepository en Spring Boot](#-integraci√≥n-de-querydsl-con-jparepository-en-spring-boot)
  - [1Ô∏è‚É£ Dependencias necesarias](#1Ô∏è‚É£-dependencias-necesarias)
  - [2Ô∏è‚É£ Entidad de ejemplo](#2Ô∏è‚É£-entidad-de-ejemplo)
  - [3Ô∏è‚É£ Repositorio base](#3Ô∏è‚É£-repositorio-base)
  - [4Ô∏è‚É£ Interfaz personalizada](#4Ô∏è‚É£-interfaz-personalizada)
  - [5Ô∏è‚É£ Implementaci√≥n con QueryDSL](#5Ô∏è‚É£-implementaci√≥n-con-querydsl)
  - [6Ô∏è‚É£ Uso en un servicio](#6Ô∏è‚É£-uso-en-un-servicio)
  - [7Ô∏è‚É£ Diferencia con `JpaRepository`](#7Ô∏è‚É£-diferencia-con-jparepository)

---

## 1. Introducci√≥n

Spring Boot ofrece varias formas de construir consultas:

* **JPQL/NamedQuery** ‚Üí consultas est√°ticas.
* **Criteria API** ‚Üí consultas din√°micas tipadas.
* **Spring Data JPA Repositories** ‚Üí abstracci√≥n sencilla (`CrudRepository`, `JpaRepository`).
* **QueryDSL** ‚Üí API fluida y tipada, m√°s expresiva que Criteria API.

üëâ **Regla pr√°ctica:**

* Para consultas simples ‚Üí usar `JpaRepository`.
* Para consultas est√°ticas complejas ‚Üí usar JPQL/NamedQuery.
* Para consultas din√°micas ‚Üí preferir **Criteria API** o mejor a√∫n, **QueryDSL**.

---

## 2. Criteria API

### Ventajas y desventajas

‚úÖ Tipada (menos errores de sintaxis).
‚úÖ Perfecta para **consultas din√°micas** con filtros opcionales.
‚ùå Verbosa, c√≥digo poco legible.

### Ejemplos b√°sicos

**B√∫squeda por atributo:**

```java
public List<Client> findByName(String name) {
    CriteriaBuilder cb = em.getCriteriaBuilder();
    CriteriaQuery<Client> cq = cb.createQuery(Client.class);
    Root<Client> root = cq.from(Client.class);

    cq.select(root).where(cb.equal(root.get("name"), name));

    return em.createQuery(cq).getResultList();
}
```

**Filtros din√°micos:**

```java
List<Predicate> predicates = new ArrayList<>();
if (name != null) predicates.add(cb.equal(root.get("name"), name));
if (city != null) predicates.add(cb.equal(root.get("city"), city));

cq.where(cb.and(predicates.toArray(new Predicate[0])));
```

---

## 3. QueryDSL

### ¬øQu√© es QueryDSL?

Es una **librer√≠a para construir consultas tipadas** sobre JPA/Hibernate, mucho m√°s **fluida y expresiva** que Criteria API.
Se basa en clases generadas llamadas **Q-classes** (`QClient`, `QAddress`, etc.), que representan tus entidades con atributos tipados.

üëâ Ventajas:

* Sintaxis clara y fluida.
* Autocompletado del IDE (atributos tipados).
* Menos verboso que Criteria.

---

### Dependencias en Spring Boot

En `build.gradle`:

```gradle
implementation "com.querydsl:querydsl-jpa"
annotationProcessor "com.querydsl:querydsl-apt:5.0.0:jpa"
```

En `pom.xml` (Maven):

```xml
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-apt</artifactId>
    <version>5.0.0</version>
    <scope>provided</scope>
</dependency>
```

---

### Generaci√≥n de Q-classes

Se generan autom√°ticamente al compilar (`mvn compile` o `gradle build`).
Ejemplo generado para `Client`:

```java
public class QClient extends EntityPathBase<Client> {
    public static final QClient client = new QClient("client");
    public final StringPath name = createString("name");
    public final NumberPath<Long> id = createNumber("id", Long.class);
}
```

---

### Ejemplos b√°sicos (QueryDSL)

**Consulta simple:**

```java
QClient client = QClient.client;

List<Client> results = new JPAQuery<>(em)
    .select(client)
    .from(client)
    .where(client.name.eq("Juan"))
    .fetch();
```

**Filtros din√°micos:**

```java
QClient client = QClient.client;
BooleanBuilder builder = new BooleanBuilder();

if (name != null) builder.and(client.name.eq(name));
if (city != null) builder.and(client.city.eq(city));

List<Client> results = new JPAQuery<>(em)
    .select(client)
    .from(client)
    .where(builder)
    .fetch();
```

**Join con direcciones:**

```java
QClient client = QClient.client;
QAddress address = QAddress.address;

List<Client> results = new JPAQuery<>(em)
    .select(client)
    .from(client)
    .join(client.addresses, address)
    .where(address.street.eq("Avd. Florida"))
    .fetch();
```

---

### Comparativa con Criteria API

| Caracter√≠stica     | Criteria API             | QueryDSL                               |
| ------------------ | ------------------------ | -------------------------------------- |
| **Legibilidad**    | Verboso, dif√≠cil de leer | Sintaxis fluida y clara                |
| **Dinamismo**      | Bueno con `Predicate`    | Excelente con `BooleanBuilder`         |
| **Autocompletado** | Limitado                 | Completo (clases Q generadas)          |
| **Dependencias**   | Incluido en JPA          | Requiere `querydsl-jpa` y `apt`        |
| **Uso t√≠pico**     | Proyectos con JPA b√°sico | Proyectos grandes, consultas complejas |

üëâ **Conclusi√≥n**: QueryDSL es m√°s expresivo y potente, ideal para proyectos medianos y grandes.

---

## 4. Buenas pr√°cticas

1. Si necesitas **filtros din√°micos** ‚Üí usar QueryDSL con `BooleanBuilder`.
2. Encapsular consultas en **repositorios personalizados** (`CustomRepositoryImpl`).
3. Para consultas simples ‚Üí mantener `JpaRepository` (m√°s legible).
4. En equipos grandes ‚Üí preferir QueryDSL sobre Criteria API.

---

‚úÖ Con esto tienes un **manual completo** de Criteria API y QueryDSL en Spring Boot.

---

Perfecto üôå Te preparo un ejemplo de c√≥mo integrar **QueryDSL** dentro de un `JpaRepository` en Spring Boot.

---

# üìò Integraci√≥n de QueryDSL con JpaRepository en Spring Boot

---

## 1Ô∏è‚É£ Dependencias necesarias

En **Maven**:

```xml
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-jpa</artifactId>
</dependency>
<dependency>
    <groupId>com.querydsl</groupId>
    <artifactId>querydsl-apt</artifactId>
    <version>5.0.0</version>
    <scope>provided</scope>
</dependency>
```

En **Gradle**:

```gradle
implementation "com.querydsl:querydsl-jpa"
annotationProcessor "com.querydsl:querydsl-apt:5.0.0:jpa"
```

üëâ Al compilar (`mvn compile` o `gradle build`), se generan las **Q-classes** (`QClient`, `QAddress`, etc.).

---

## 2Ô∏è‚É£ Entidad de ejemplo

```java
@Entity
public class Client {
    @Id @GeneratedValue
    private Long id;
    private String name;
    private String city;
    
    @OneToMany
    private List<Address> addresses = new ArrayList<>();
}
```

---

## 3Ô∏è‚É£ Repositorio base

```java
public interface ClientRepository extends JpaRepository<Client, Long>, ClientRepositoryCustom {
}
```

---

## 4Ô∏è‚É£ Interfaz personalizada

```java
public interface ClientRepositoryCustom {
    List<Client> searchClients(String name, String city);
}
```

---

## 5Ô∏è‚É£ Implementaci√≥n con QueryDSL

```java
public class ClientRepositoryImpl implements ClientRepositoryCustom {

    @PersistenceContext
    private EntityManager em;

    @Override
    public List<Client> searchClients(String name, String city) {
        QClient client = QClient.client;
        BooleanBuilder builder = new BooleanBuilder();

        if (name != null) {
            builder.and(client.name.eq(name));
        }
        if (city != null) {
            builder.and(client.city.eq(city));
        }

        return new JPAQuery<>(em)
                .select(client)
                .from(client)
                .where(builder)
                .fetch();
    }
}
```

üìå Notas:

* `ClientRepositoryImpl` debe **terminar en "Impl"** para que Spring la detecte autom√°ticamente como implementaci√≥n de la interfaz `ClientRepositoryCustom`.
* Usamos `BooleanBuilder` para **filtros din√°micos**.

---

## 6Ô∏è‚É£ Uso en un servicio

```java
@Service
public class ClientService {

    private final ClientRepository clientRepository;

    public ClientService(ClientRepository clientRepository) {
        this.clientRepository = clientRepository;
    }

    public void demoQueryDSL() {
        List<Client> results = clientRepository.searchClients("Juan", "Madrid");
        results.forEach(c -> System.out.println("Cliente: " + c.getName()));
    }
}
```

---

## 7Ô∏è‚É£ Diferencia con `JpaRepository`

| Caracter√≠stica        | `JpaRepository`                           | `QueryDSL + Custom Repo`                  |
| --------------------- | ----------------------------------------- | ----------------------------------------- |
| Consultas simples     | M√©todos m√°gicos (`findByName`)            | No necesario                              |
| Consultas complejas   | Dif√≠cil con `@Query`                      | Muy f√°cil y din√°mico con `BooleanBuilder` |
| Filtros din√°micos     | Limitados (se necesitan `Specifications`) | Naturales con `QueryDSL`                  |
| Autocompletado en IDE | Solo en nombres de m√©todos                | Completo con Q-classes                    |

---